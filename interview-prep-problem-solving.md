# 인터뷰 예상 질문 & 답변 - 문제 해결 역량

## Q1. 장애 대응 경험이 있나요?

**답변:**
대규모 서비스를 운영하면서 다양한 장애 대응 경험을 쌓았습니다.

**장애 예방:**
- Spring Cloud Circuit Breaker로 장애 전파 방지
- 재시도 정책 정교화로 운영 안정성 확보
- 좀비 토큰 자동 만료 등 운영 자동화
- 실시간 모니터링 프로세스 구축

**장애 발생 시:**
1. 신속한 원인 파악: 로그 분석, 모니터링 데이터 확인
2. 임시 조치: 서비스 영향 최소화
3. 근본 원인 해결: 코드 수정, 인프라 개선
4. 재발 방지: 테스트 케이스 추가, 모니터링 강화

**성과:**
- 가상 순번 대기 시스템 운영 중 월 1일 대규모 이벤트 기간 코어 시스템 지연 장애 0건

---

## Q2. 레거시 코드 개선 경험이 있나요?

**답변:**
기존 플랫폼 서비스 운영 개발을 하면서 지속적으로 레거시 코드를 개선하고 있습니다.

**개선 방향:**
- **아키텍처 개선:** 헥사고날 아키텍처, 클린 아키텍처, DDD 등 설계 원칙 적용
- **리팩토링:** 코드 가독성, 유지보수성 향상
- **성능 개선:** 불필요한 DB Lock 제거, 캐싱 전략 적용, 비동기 처리 도입
- **보안 강화:** 인증 프로세스 개선, 개인정보 암호화

**사례:**
- 민생회복 소비쿠폰 시스템 개선 시 불필요한 DB Lock 조회 로직 제거
- 가맹점 연동 Batch 시스템을 동기 처리에서 병렬 비동기 처리로 전환하여 179배 성능 개선

단계적으로 개선하며, 테스트 코드를 작성하고 충분한 검증을 거친 후 배포합니다.

---

## Q3. 요구사항이 모호할 때 어떻게 대처하시나요?

**답변:**
요구사항이 모호할 때는 적극적인 소통을 통해 명확히 하려고 노력합니다.

**대응 방식:**
1. **질문하기:** 불확실한 부분을 구체적으로 질문
2. **시나리오 작성:** 예상되는 사용 사례를 정리하여 공유
3. **프로토타입:** 간단한 프로토타입을 만들어 피드백 수렴
4. **문서화:** 합의된 내용을 문서화하여 공유
5. **지속적 소통:** 개발 중에도 지속적으로 피드백 공유

**예시:**
- 가상계좌 연동 서비스 구축 시 프로젝트 리더로서 설계 단계에서 은행사 전문 규격, 거래 시나리오, 예외 처리 등을 상세히 정의하고 관련 부서와 협의하여 요구사항을 명확히 했습니다.

---

## Q4. 디버깅 시 어떤 접근 방식을 사용하시나요?

**답변:**
체계적인 디버깅 접근 방식을 사용합니다.

**디버깅 프로세스:**
1. **문제 재현:** 버그를 일관되게 재현할 수 있는 시나리오 파악
2. **가설 수립:** 로그, 스택 트레이스, 모니터링 데이터를 바탕으로 원인 가설 수립
3. **검증:** 디버거, 로그 추가, 테스트 코드 작성 등을 통해 가설 검증
4. **근본 원인 파악:** 증상이 아닌 근본 원인 파악
5. **수정 및 검증:** 코드 수정 후 테스트로 검증
6. **재발 방지:** 테스트 케이스 추가, 모니터링 강화

**활용 도구:**
- IDE 디버거 (IntelliJ IDEA)
- 로그 분석 (ELK Stack)
- APM (Application Performance Monitoring)
- 프로파일링 도구 (JProfiler, VisualVM 등)

---

## Q5. 기술 부채를 어떻게 관리하시나요?

**답변:**
기술 부채를 인식하고 체계적으로 관리하려 노력합니다.

**기술 부채 관리 전략:**
1. **식별:** 코드 리뷰, 리팩토링 시 기술 부채 식별 및 문서화
2. **우선순위 결정:** 비즈니스 영향도, 개선 난이도를 고려하여 우선순위 결정
3. **점진적 개선:** 신규 기능 개발과 병행하여 점진적으로 개선
4. **전략적 선택:** 때로는 빠른 구현을 위해 의도적으로 기술 부채를 선택하되, 명확히 인식하고 계획적으로 해소

**예시:**
- 가맹점 연동 Batch 시스템: 처음에는 동기 처리로 빠르게 구현했으나, 성능 이슈가 발생하자 병렬 비동기 처리로 리팩토링하여 179배 성능 개선
- 레거시 아키텍처: 헥사고날 아키텍처, 클린 아키텍처, DDD 등을 점진적으로 적용하여 유지보수성 향상

**원칙:**
- 완벽한 설계보다는 동작하는 코드를 먼저 만들고, 지속적으로 개선
- 기술 부채를 팀과 공유하고 함께 해소 계획 수립

---

## Q6. 복잡한 문제를 어떻게 단순화하시나요?

**답변:**
복잡한 문제를 작은 단위로 분해하고 단계적으로 해결합니다.

**문제 해결 접근 방식:**
1. **문제 이해:** 문제의 본질과 요구사항 명확히 파악
2. **분해:** 큰 문제를 작은 하위 문제로 분해
3. **우선순위:** 핵심적이고 중요한 문제부터 해결
4. **단계적 구현:** 작은 단위로 구현하고 검증하며 점진적 개선
5. **추상화:** 공통 패턴을 찾아 추상화하여 재사용성 향상

**예시:**
- **가상 순번 대기 시스템 개발 시:**
  1. 대기열 순번 발급 → 2. 진입 처리 제어 → 3. 좀비 토큰 관리 → 4. 모니터링 → 5. Auto-Scaling
  각 단계를 독립적으로 구현하고 통합하여 100K 동시접속 처리 시스템 완성

- **주소 검색 시스템 최적화 시:**
  1. 데이터 파이프라인 구축 → 2. 인덱스 설계 → 3. 애널라이저 구성 → 4. 검색 쿼리 개선
  단계별로 성능을 측정하며 점진적으로 개선하여 응답시간 3배 향상

---

## Q7. 트레이드오프 상황에서 어떻게 의사결정을 하시나요?

**답변:**
여러 요소를 종합적으로 고려하여 최선의 선택을 합니다.

**의사결정 기준:**
- **비즈니스 우선순위:** 비즈니스 목표와 요구사항
- **기술적 타당성:** 확장성, 유지보수성, 성능
- **리소스:** 개발 시간, 비용, 팀 역량
- **위험도:** 기술적 리스크, 운영 리스크

**의사결정 프로세스:**
1. 각 선택지의 장단점 분석
2. 팀과 함께 논의
3. 프로토타입 또는 PoC (Proof of Concept)로 검증
4. 데이터 기반 의사결정 (성능 테스트, 벤치마크 등)

**예시:**
- **가상 순번 대기 시스템 개발 시 외부 솔루션 vs 자체 개발:**
  - 외부 솔루션: 빠른 구현, 검증된 안정성 / 비용 높음, 커스터마이징 어려움
  - 자체 개발: 커스터마이징 자유, 비용 절감 / 개발 시간 소요, 검증 필요
  - **결정:** 비용, 커스터마이징 요구사항, 팀 기술 역량을 고려하여 Redis 기반 자체 개발 선택
  - **결과:** 성공적으로 100K 동시접속 안정 제어, 요구사항에 맞는 유연한 구현

- **성능 vs 가독성:**
  - 초기에는 가독성을 우선하여 명확한 코드 작성
  - 성능 이슈 발생 시 프로파일링으로 병목 지점 파악 후 선택적으로 최적화
  - 최적화 시에도 주석, 테스트 코드로 의도를 명확히 표현

---

## Q8. 프로젝트 일정이 촉박할 때 어떻게 대응하시나요?

**답변:**
우선순위를 명확히 하고 효율적으로 대응합니다.

**대응 전략:**
1. **범위 조정:** 필수 기능과 선택 기능 구분, 단계적 릴리즈 계획
2. **우선순위:** 비즈니스 영향도가 높은 기능 우선 개발
3. **기술 부채 인식:** 빠른 구현을 위해 기술 부채를 선택하되, 명확히 인식하고 추후 개선 계획 수립
4. **팀 협업 강화:** 페어 프로그래밍, 코드 리뷰로 품질 유지하면서 개발 속도 향상
5. **소통:** 이해관계자와 지속적으로 소통하며 현실적인 일정 조율

**원칙:**
- 품질을 희생하지 않는 범위 내에서 효율성 추구
- 핵심 기능의 안정성은 절대 타협하지 않음
- 테스트, 보안, 문서화는 최소한의 수준 유지

**예시:**
- 민생회복 소비쿠폰 시스템 개선 시 촉박한 일정에도 불구하고 개인정보 암호화, DB Lock 제거 등 핵심 기능을 우선 구현하고, 부가 기능은 단계적으로 릴리즈
